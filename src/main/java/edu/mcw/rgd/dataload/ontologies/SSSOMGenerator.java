package edu.mcw.rgd.dataload.ontologies;

import edu.mcw.rgd.datamodel.Omim;
import edu.mcw.rgd.datamodel.ontologyx.Term;
import edu.mcw.rgd.datamodel.ontologyx.TermSynonym;
import edu.mcw.rgd.process.Utils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.BufferedWriter;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.*;

public class SSSOMGenerator {

    private String version;

    private final Logger logger = LogManager.getLogger("sssomMappings");
    private OntologyDAO dao = new OntologyDAO();

    static SimpleDateFormat sdtCreationDate = new SimpleDateFormat("yyyy-MM-dd");

    public void run() throws Exception {

        run("RDO", "MIM");

        run("EFO", "CMO");
        run("EFO", "MP");
        run("EFO", "HP");
        run("EFO", "VT");
        run("EFO", "RDO");
    }

    void run(String ontId1, String ontId2) throws Exception {

        String fileName = ontId1.toLowerCase()+"_"+ontId2.toLowerCase()+"_rgd.sssom.tsv.txt";
        String dirName = "data/ontology/mappings";
        String outFileName = dirName+"/"+fileName;

        File dir = new File(dirName);
        if( !dir.exists() ) {
            dir.mkdirs();
            logger.info("created directory "+dirName);
        }

        BufferedWriter out = Utils.openWriter(outFileName);

        String headerTemplate = """
        #mapping_provider: RGD
        #mapping_tool: RGD SSSOM file generator
        #mapping_tool_version: ###VERSION###
        #mapping_set_id: https://download.rgd.mcw.edu/ontology/mappings/###FILENAME###
        #mapping_set_title: All mappings of ###ONT1### terms to ###ONT2### terms generated by RGD (draft version)
        #mapping_set_description: All mappings of ###ONT1### terms to ###ONT2### terms generated by RGD (draft version)
        #license: https://creativecommons.org/licenses/by/4.0/
        #object_source: obo:###ONT1###
        #subject_source: obo:###ONT2###
        #curie_map:
        # ###ONT1###: http://purl.obolibrary.org/obo/###ONT1###_
        # ###ONT2###: http://purl.obolibrary.org/obo/###ONT2###_
        # skos: http://www.w3.org/2004/02/skos/core#
        # orcid: https://orcid.org/
        # obo: http://purl.obolibrary.org/obo/
        # semapv: https://w3id.org/semapv/vocab/
        object_id\tobject_label\tpredicate_id\tsubject_id\tsubject_label\tmapping_justification\tmapping_date
        """;

        String header = headerTemplate.replace("###FILENAME###", fileName)
                .replace("###ONT1###", ontId1)
                .replace("###ONT2###", ontId2)
                .replace("###VERSION###", getVersion());

        out.write(header);

        logger.info("written header to "+outFileName);

        String termAccPrefix = ontId2+":%";
        if( ontId2.equals("RDO") ) {
            termAccPrefix = "DOID:%";
        }
        List<TermSynonym> synonyms =  dao.getActiveSynonymsByNamePattern(ontId1, termAccPrefix);

        logger.info("retrieved "+synonyms.size()+" "+ontId1+" to "+ontId2+" mappings from database");

        List<String> mappings = new ArrayList<>();

        // to exclude duplicates
        Set<String> mappingIdPairs = new HashSet<>();
        int duplicateLines = 0;

        for( TermSynonym tsyn: synonyms ) {

            String objectId = getObjectId(tsyn.getTermAcc());
            String objectLabel;
            String predicateId = getPredicateId(tsyn.getType());
            String subjectId;
            String subjectLabel;
            String mappingJustification = "semapv:ManualMappingCuration";
            String mappingDate = getDateString(tsyn.getCreatedDate());

            if( objectId == null || predicateId == null ) {
                continue;
            }

            Term term = getTermByAcc(tsyn.getTermAcc());
            if( term==null ) {
                continue;
            }
            objectLabel = term.getTerm();

            term = getTermByAcc(tsyn.getName());
            if( term==null ) {
                continue;
            }

            subjectId = getObjectId(term.getAccId());
            if( subjectId==null ) {
                continue;
            }
            subjectLabel = term.getTerm();

            if( objectId.equals(subjectId) ) {
                continue;
            }

            String mappingIdPair = objectId+"|"+subjectId;
            if( mappingIdPairs.contains(mappingIdPair) ) {
                duplicateLines++;
                continue;
            }
            mappingIdPairs.add(mappingIdPair);

            mappings.add(objectId
                    +"\t"+objectLabel
                    +"\t"+predicateId
                    +"\t"+subjectId
                    +"\t"+subjectLabel
                    +"\t"+mappingJustification
                    +"\t"+mappingDate
                    +"\n"
            );
        }

        Collections.sort(mappings);

        for( String mapping: mappings ) {
            out.write(mapping);
        }

        out.close();

        int mappingsWritten = mappings.size();

        logger.info("written "+mappingsWritten+" mappings to "+fileName);
        logger.info(duplicateLines+" duplicate lines skipped");
    }

    Term getTermByAcc( String termAcc ) throws Exception {

        // MIM workaround
        if( termAcc.startsWith("MIM:") || termAcc.startsWith("OMIM:") ) {
            Omim omim = dao.getOmimByNr(termAcc);
            if( omim != null ) {
                Term term = new Term();
                term.setAccId(termAcc);
                term.setTerm(omim.getPhenotype());
                return term;
            }
        }

        return dao.getTerm(termAcc);
    }

    String getObjectId( String acc ) {

        int firstColonPos = acc.indexOf(':');
        if( firstColonPos <= 0 ) {
            return null; // no colon pos?
        }
        int secondColonPos = acc.indexOf(':', firstColonPos+1);
        if( secondColonPos <= firstColonPos ) {
            return acc;
        }
        // there is second colon: return only the part after the 1st colon
        // f.e. for EFO:MONDO:0000001' return MONDO:0000001
        return acc.substring(firstColonPos+1);
    }

    String getPredicateId( String synonymType ) {

        return switch (synonymType) {
            case "exact_synonym", "primary_id", "alt_id", "xref", "exact_xref"
                                                      -> "skos:exactMatch";
            case "narrow_synonym", "narrow_xref"      -> "skos:narrowMatch";
            case "broad_synonym", "broad_xref"        -> "skos:broadMatch";
            case "related_synonym", "related_xref"    -> "skos:relatedMatch";
            default -> null;
        };
    }

    String getDateString( Date dt ) {

        if( dt==null ) {
            return "";
        }

        return sdtCreationDate.format(dt);
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }
}
